from tkinter import E
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
from sensor_msgs.msg import NavSatFix
import math # need a solution instead of imported it twice
from . import utilities # need to look into that .
from .PID_controller import  PID
from std_msgs.msg import Int16
from std_msgs.msg import Float32

class TurtleBot(Node):
    """
    main class to control turtlebot and ros interface 
    
    The parent class shuld have the function stop and run for both manual and Auto
    """

    def __init__(self):
        super().__init__('turtle_bot')
        self.gps_sub = self.create_subscription(NavSatFix, 'gps/fix', self.gps_callback, 1) # check how to handle the data not be lossed using except
        self.imu_sub = self.create_subscription(Imu, 'imu/data', self.imu_callback, 1)
        self.subscription = self.create_subscription(Int16,'mode_control',self.listener_callback,1)
        self.manual_speed_controller_sub = self.create_subscription(Float32,'mode_control',self.manual_speed_controller,1)
        self.cmd_pub = self.create_publisher(Twist, 'cmd_vel', 1)
        timer_period = 0.5  # seconds       add that to a config file
        self.timer_ = self.create_timer(timer_period, self.set_velocity)
        self.pid_controller = PID(1.0,0,0)                                              # Add gians param to ros param   read is that a decompostion or aggregation
        self.robot_yaw = 0.0                                                            # check if unnecessary global
        self.heading_angle = 0.0                                                        # check if unnecessary global
        self.angle_error = 0.0                                                          # make this private
        self.variable = 0
        self.cmd_message = Twist()

    def manual_speed_controller(self,msg):
        pass # the input will be the speed
        

        
    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)
        if msg.data ==1:
            self.variable = 1
            self.rest()
        if msg.data ==2:
            self.variable = 2
            self.rest()


    def gps_callback(self,msg):                             #save the data first then pass it
        # self.get_logger().info('Recieved - Latitude : %f, Longtitude : %f' % (msg.latitude, msg.longitude))
        self.calculate_heading_angle(msg.latitude,msg.longitude)  # this should not be called from here
       
        #self.get_logger().info('The Angle to Greewich is : %f' % (self.heading_angle))

    def imu_callback(self, msg):
        #self.get_logger().info('Recieved - orientation : %f' % (msg.orientation.w))
        roll,pitch,self.robot_yaw = utilities.euler_from_quaternion(msg.orientation)            # check the unused variables like matlab
        #self.get_logger().info('The Angle to Greewich is : %f' % (self.angle_error))

      #  self.get_logger().info('Recieved - orientation : %f' % (math.degrees(self.robot_yaw))) # To make sure test use this website https://www.igismap.com/map-tool/bearing-angle

    def set_velocity(self): # this function should only set the velocity

         
        if(self.variable ==1):
            self.cmd_message.angular.z = self.angle_error
            self.calculate_angle_of_rotation()
            self.cmd_pub.publish(self.cmd_message)
        
        elif self.variable ==2:

            self.cmd_message.linear.x = 0.5
            self.cmd_pub.publish(self.cmd_message)

    def rest(self):
            self.cmd_message.angular.z = 0.0
            self.cmd_message.linear.x  = 0.0
            self.cmd_pub.publish(self.cmd_message)

    def move_forward():
         pass


    def calculate_heading_angle(self,Latitude,Longtitude):
        greenwich_longtitude = -0.001545                        # use ros param 
        greenwich_latitude = 51.477928                          # need to use ros param
        robot_coordinates = (Latitude,Longtitude)
        greenwich_coordinates = (greenwich_latitude,greenwich_longtitude)
        self.heading_angle = utilities.calculate_initial_compass_bearing(robot_coordinates,greenwich_coordinates)

    def calculate_angle_of_rotation(self):
        self.angle_error =   self.heading_angle - self.robot_yaw
        # the robot should follow the smallest distance to its target
        if self.angle_error > math.pi:
            self.angle_error -= 2 * math.pi
        if self.angle_error < - math.pi:
            self.angle_error += 2 * math.pi
        self.angle_error = self.pid_controller.update_controller(self.angle_error)
        

    def clip_max_velocity(self):
        pass



def main(args=None):

    rclpy.init(args=args)
    turtlebot = TurtleBot()
    rclpy.spin(turtlebot)
    turtlebot.destroy_node()    
    rclpy.shutdown()  
    
if __name__ == '__main__':
    main()